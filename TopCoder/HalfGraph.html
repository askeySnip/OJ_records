<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>Let G=(V,E) be an undirected graph. </p>

<p>A <i>spanning subgraph</i> of G is a graph that can be created by removing some (possibly empty) subset of edges from G. Note that a spanning subgraph must still contain all vertices of the original graph G.</p>

<p>A spanning subgraph H is called a <i>half</i> of G if the degree of every vertex v in H is exactly half of its degree in G.</p>

<p>You are given vector &lt;string&gt; <b>a</b>: the adjacency matrix of the graph G. More precisely, <b>a</b>[i][j] is '1' if vertices i and j are connected by an edge, and it is '0' if they are not.</p>

<p>Find and return the adjacency matrix of any graph that is a half of G. If there are multiple answers, you may return any one of them. If there are no answers, output an empty vector &lt;string&gt; instead.</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>HalfGraph</td></tr><tr><td>Method:</td><td>compute</td></tr><tr><td>Parameters:</td><td>vector &lt;string&gt;</td></tr><tr><td>Returns:</td><td>vector &lt;string&gt;</td></tr><tr><td>Method signature:</td><td>vector &lt;string&gt; compute(vector &lt;string&gt; a)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>n will be between 1 and 50, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>a</b> has exactly n elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>a</b> is a string of length n, consisting of characters '0' and '1' only.</td></tr><tr><td align="center" valign="top">-</td><td>The matrix is symmetric, i.e., for all i,j we have a[i][j] = a[j][i].</td></tr><tr><td align="center" valign="top">-</td><td>The main diagonal contains only characters '0'. In other words, the graph doesn't contain any loops.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;000&quot;,
 &quot;000&quot;,
 &quot;000&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {&quot;000&quot;, &quot;000&quot;, &quot;000&quot; }</pre></td></tr><tr><td><table><tr><td colspan="2">An empty graph is its own half, because the half of zero is zero.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;01111&quot;,
 &quot;10111&quot;,
 &quot;11011&quot;,
 &quot;11101&quot;,
 &quot;11110&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {&quot;00011&quot;, &quot;00110&quot;, &quot;01001&quot;, &quot;11000&quot;, &quot;10100&quot; }</pre></td></tr><tr><td><table><tr><td colspan="2">The input is a complete graph G on five vertices. In the graph G the degree of each vertex is 4. Thus, the output can be any subgraph of G that has 5 vertices and in which the degree of each vertex is 2.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;010&quot;,
 &quot;101&quot;,
 &quot;010&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2">This graph contains the edges 0-1 and 1-2. It does not have any half, because you cannot have a vertex of degree 1/2.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;01111&quot;,
 &quot;10100&quot;,
 &quot;11000&quot;,
 &quot;10001&quot;,
 &quot;10010&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {&quot;00011&quot;, &quot;00100&quot;, &quot;01000&quot;, &quot;10000&quot;, &quot;10000&quot; }</pre></td></tr><tr><td><table><tr><td colspan="2">Remember that the returned graph must be a subgraph of the original one. You are not allowed to add new edges, you may only erase the existing ones.</td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
