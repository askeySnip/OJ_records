<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
Mojtaba is Arpa's kind teacher.
Once, he gave Arpa a problem to solve.
The problem looked as follows:
</p>
<p><i>
There is an <b>n</b> times <b>n</b> chessboard, with both rows and columns numbered from 1 to <b>n</b>.
Some unit cubes are placed onto the chessboard in such a way that each cube occupies a single cell.
Each cube has a different color, and a different target cell it should occupy.
You can move cubes by sliding them.
More precisely, in a single move you can slide a single cube from its current cell into an empty adjacent cell.
Find one sequence of moves that will move all cubes to their target cells.
</i></p>
<p>
Arpa has already implemented his solution and he asked Mojtaba to test it.
As the solution is not unique, Mojtaba would need a checker.
But now he is occupied with the preparation of Qadir festival, so he kindly asked you to help and do that.
</p>
<p>
You are given the int <b>n</b>: the dimension of the chessboard.
You are also given the vector &lt;int&gt;s <b>startRow</b>, <b>startCol</b>, <b>destRow</b>, and <b>destCol</b>.
The length of <b>startRow</b> is the number of cubes.
For each valid i, there is a cube that starts in row <b>startRow</b>[i] and column <b>startCol</b>[i], and this cube should be pushed to row <b>destRow</b>, column <b>destCol</b>.
This is the input data for the problem, and you can assume that it is valid.
</p>
<p>
Finally, you are given the vector &lt;int&gt;s
<b>moveStartRow</b>, <b>moveStartCol</b>, <b>moveDestRow</b>, and <b>moveDestCol</b>.
These contain Arpa's solution.
Their meaning is as follows:
for each valid index i (starting with 0, 1, 2, ...), one should move the cube that is currently 
in row <b>moveStartRow</b>[i] and column <b>moveStartCol</b>[i], and slide this cube to row <b>moveDestRow</b>, column <b>moveDestCol</b>.
</p>
<p>
We already did some simple tests for you: we made sure that all four arrays that describe Arpa's solution have the same length and contain integers only.
The rest is up to you.
</p>
<p>
Return "valid" if the arrays <b>move</b>* contain a valid solution to the puzzle described by the other parameters.
Otherwise, return "invalid".
</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>CCChecker2</td></tr><tr><td>Method:</td><td>check</td></tr><tr><td>Parameters:</td><td>int, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>string</td></tr><tr><td>Method signature:</td><td>string check(int n, vector &lt;int&gt; startRow, vector &lt;int&gt; startCol, vector &lt;int&gt; destRow, vector &lt;int&gt; destCol, vector &lt;int&gt; moveStartRow, vector &lt;int&gt; moveStartCol, vector &lt;int&gt; moveDestRow, vector &lt;int&gt; moveDestCol)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>1.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>n</b> will be between 1 and 6.</td></tr><tr><td align="center" valign="top">-</td><td>Length of <b>startRow</b>, <b>startCol</b>, <b>destRow</b>, and, <b>destCol</b> will be equal, and it will be between 0 and 5, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Length of <b>moveStartRow</b>, <b>moveStartCol</b>, <b>moveDestRow</b>, and, <b>moveDestCol</b> will be equal, and they will be between 0 and 50, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>startRow</b>, <b>startCol</b>, <b>destRow</b>, and, <b>destCol</b> will be between 1 and <b>n</b>, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>moveStartRow</b>, <b>moveStartCol</b>, <b>moveDestRow</b>, and, <b>moveDestCol</b> can be any 32-bit integer.</td></tr><tr><td align="center" valign="top">-</td><td>Start position of cubes will not coincide.</td></tr><tr><td align="center" valign="top">-</td><td>Destinations of cubes will not coincide.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>2</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{2}</pre></td></tr><tr><td><pre>{2}</pre></td></tr><tr><td><pre>{1, 1}</pre></td></tr><tr><td><pre>{1, 2}</pre></td></tr><tr><td><pre>{1, 2}</pre></td></tr><tr><td><pre>{2, 2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;valid&quot;</pre></td></tr><tr><td><table><tr><td colspan="2">There is a single cube. It starts at (1,1) and we should move it to (2,2).
The last four arrays describe one valid solution: in step 0 we move a cube from (1,1) to (1,2), and in step 1 we then move a cube from (1,2) to (2,2).</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>2</pre></td></tr><tr><td><pre>{1, 2}</pre></td></tr><tr><td><pre>{1, 2}</pre></td></tr><tr><td><pre>{1, 2}</pre></td></tr><tr><td><pre>{2, 1}</pre></td></tr><tr><td><pre>{2, 1, 2, 1, 2, 1, 2, 2}</pre></td></tr><tr><td><pre>{2, 1, 1, 2, 2, 1, 1, 2}</pre></td></tr><tr><td><pre>{1, 2, 2, 1, 1, 2, 2, 2}</pre></td></tr><tr><td><pre>{2, 1, 2, 1, 2, 1, 2, 1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;valid&quot;</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
Now there are two cubes: a red cube that should go from (1,1) to (1,2), and a blue cube that should go from (2,2) to (2,1).
</p>
<p>
Again, the <b>move</b>* arrays represent a valid solution. It's not the shortest solution possible, but that is not required.
</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>6</pre></td></tr><tr><td><pre>{}</pre></td></tr><tr><td><pre>{}</pre></td></tr><tr><td><pre>{}</pre></td></tr><tr><td><pre>{}</pre></td></tr><tr><td><pre>{}</pre></td></tr><tr><td><pre>{}</pre></td></tr><tr><td><pre>{}</pre></td></tr><tr><td><pre>{}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;valid&quot;</pre></td></tr><tr><td><table><tr><td colspan="2">If there are no cubes, then doing nothing is a valid solution.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{-47}</pre></td></tr><tr><td><pre>{-42}</pre></td></tr><tr><td><pre>{125216547}</pre></td></tr><tr><td><pre>{125216547}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;invalid&quot;</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
Arpa's program has produced some garbage. These are not even valid coordinates!
</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{3}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;invalid&quot;</pre></td></tr><tr><td><table><tr><td colspan="2">In each step we have to move a cube by a single cell.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>6</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{2}</pre></td></tr><tr><td><pre>{2}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{2}</pre></td></tr><tr><td><pre>{2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;invalid&quot;</pre></td></tr><tr><td><table><tr><td colspan="2">Diagonal moves are not allowed either.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">6)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{1,2}</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{3,2}</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{1,2}</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{2,3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;invalid&quot;</pre></td></tr><tr><td><table><tr><td colspan="2"><p>Here we have two cubes. One starts at (1,1) and should end at (1,3), the other should start and end at (1,2).</p>
<p>The arrays <b>move</b>* describe two instructions: move a cube from (1,1) to (1,2), and move a cube from (1,2) to (1,3).</p>
<p>This is not a valid solution. In step 0 we cannot move the cube from (1,1) to (1,2), because this cell is currently occupied.</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">7)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{1,2}</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{3,2}</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{2,1}</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{3,2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;invalid&quot;</pre></td></tr><tr><td><table><tr><td colspan="2"><p>This is the same collection of cubes and destinations as in the previous example. This solution is not valid either: the cubes are at the destination cells, but their positions are swapped. Remember that each cube has its own color and its own designated cell.</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">8)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{1,2}</pre></td></tr><tr><td><pre>{1,1}</pre></td></tr><tr><td><pre>{3,2}</pre></td></tr><tr><td><pre>{1,1,1,2}</pre></td></tr><tr><td><pre>{2,1,2,2}</pre></td></tr><tr><td><pre>{2,1,1,1}</pre></td></tr><tr><td><pre>{2,2,3,2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;valid&quot;</pre></td></tr><tr><td><table><tr><td colspan="2"><p>For the third time we have the same cubes and the same destinations. Now we have a valid solution: move the cube from (1,2) to row 2, in two moves get the cube from (1,1) to (1,3), and then return the other cube from (2,2) back to (1,2) where it belongs.</p></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
