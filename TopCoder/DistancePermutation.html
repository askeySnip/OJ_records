<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>Limak has a tree with N vertices that are numbered 0 through N-1.
He wants to find a treasure that is hidden in one random vertex.
Each vertex is equally likely to contain the treasure.</p>
<p>Every vertex contains a detector that Limak can use to get the distance to the vertex with the hidden treasure.</p>
<p>Limak is going to use the detectors in a random order (each of N! orders is equally likely), and he will stop immediately when he is sure where the treasure is.
Can you find the expected value of the number of used detectors?</p>
<p>You are given the vector &lt;int&gt; <b>parent</b> of length N-1 that describes the tree.
For every i between 1 and N-1 inclusive, vertices i and <b>parent</b>[i-1] are connected by an edge.</p>
<p>Let X denote the expected value of the number of detectors Limak will use.
It can be proved that X*N*(N!) is an integer.
Find and return (X*N*(N!)) modulo 1,000,000,007.</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>DistancePermutation</td></tr><tr><td>Method:</td><td>solve</td></tr><tr><td>Parameters:</td><td>vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int solve(vector &lt;int&gt; parent)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>The distance between two vertices is the number of edges on the shortest path between them.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>N will be between 1 and 50, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>parent</b> will contain exactly N-1 elements.</td></tr><tr><td align="center" valign="top">-</td><td>For every valid i, <b>parent</b>[i] will be between 0 and i, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 4</pre></td></tr><tr><td><table><tr><td colspan="2"><p>The tree consists of two vertices connected by an edge.
It's always enough to use one detector.
If it displays the distance 0, the treasure is in our current vertex.
If it displays the distance 1, the treasure is in the other vertex.</p>
<p>The expected value of the number of detectors used is 1 and multiplying it by N*(N!) gives the answer 4.</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 22</pre></td></tr><tr><td><table><tr><td colspan="2"><p>There are three vertices and the edges are 0-1 and 0-2.
If Limak first uses a detector in vertex 1 or vertex 2, the displayed distance will be 0, 1 or 2, and Limak will immediately determine where the treasure is.
If the first used detector is in vertex 0 and it displays distance 0, the treasure must be in this vertex.
But if the distance is 1, Limak needs one more detector to say which of the other two vertices contains the treasure.</p>
<br></br>
<p>Using two detectors is necessary only if Limak first uses a detector in vertex 0 and the treasure is in vertex 1 or vertex 2.
The probability of that is 1/3 * 2/3 = 2/9.
The expected value of the number of used detectors is 7/9 * 1 + 2/9 * 2 = 11/9.
The answer is 11/9 * 3 * (3!) = 22.</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 22</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,0,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 174</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,0,1,0,2,3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 61008</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 0</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
