<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
This problem is about ordinary binary search trees (BSTs).
Your task is simple: just simulate a sequence of <b>n</b> insertions.
</p>
<p>
Inserting an element into a BST is simple:
Inserting into an empty BST produces a BST with a single node, containing the inserted value.
If we already have a nonempty BST, inserting X is done as follows:
Search for X in the BST.
If you find it, do nothing.
If you don't find it, create a new node containing X and attach it as a leaf to the existing BST in the only valid way.
</p>
<p>
For example, if we start with an empty BST and insert the values { 40, 20, 60, 70, 80, 30, 10, 30, 90 } in this order, we will get the following tree:
</p>
<pre>
            40
           /  \ 
         20    60
        /  \     \
      10    30    70
                    \
                     80
                       \
                        90
</pre>
<p>
The depth of a node is defined as 1 plus the depth of its parent, with the depth of the root being 0.
Let D(x) denote the depth of the node that contains the number x.
</p>
<p>
Your task will be to insert the values S(0), S(1), ..., S(<b>n</b>-1) and to return the following checksum: sum( D(S(i)) * 10^(5*i) ) modulo (10^9 + 7).
</p>
<p>
In order to keep the input size small and to force you to process the elements of S one at a time, the sequence S is defined recursively.
You are given a vector &lt;int&gt; <b>Sprefix</b> with p elements: the values S(0), ..., S(p-1).
Each of the following elements of S is computed as follows:
S(i) = (<b>a</b> * S(i-p) + D(S(i-1)) + 1) modulo <b>m</b>.
</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>SimulateBST</td></tr><tr><td>Method:</td><td>checksum</td></tr><tr><td>Parameters:</td><td>int, vector &lt;int&gt;, int, int</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int checksum(int n, vector &lt;int&gt; Sprefix, int a, int m)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>n</b> will be between 1 and 500,000, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>m</b> will be between 1 and 1,000,000,007, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>a</b> will be between 0 and <b>m</b>-1, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>Sprefix</b> will have between 1 and min(200,<b>n</b>) elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>Sprefix</b> will be between 0 and <b>m</b>-1, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>{10, 20, 30}</pre></td></tr><tr><td><pre>0</pre></td></tr><tr><td><pre>100</pre></td></tr></table></td></tr><tr><td><pre>Returns: 99860</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
The resulting tree looks as follows:
</p>
<pre>
10
  \
   20
     \
      30
</pre>
<p>
The inserted values appear in the depths {0, 1, 2}, in this order.
Thus, the correct checksum to return is (0 * 10^0 + 1 * 10^5 + 2 * 10^10) modulo 1,000,000,007.
</p>

</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>{10, 10, 10}</pre></td></tr><tr><td><pre>0</pre></td></tr><tr><td><pre>100</pre></td></tr></table></td></tr><tr><td><pre>Returns: 0</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
The resulting tree looks as follows:
</p>
<pre>
10
</pre>
<p>
The inserted values appear in the depths {0, 0, 0}, in this order.
Thus, the correct checksum to return is (0 * 10^0 + 0 * 10^5 + 0 * 10^10) modulo 1,000,000,007.
</p>

</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>{20, 10, 30}</pre></td></tr><tr><td><pre>0</pre></td></tr><tr><td><pre>100</pre></td></tr></table></td></tr><tr><td><pre>Returns: 99930</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
The resulting tree looks as follows:
</p>
<pre>
   20
  /  \
10    30
</pre>
<p>
The inserted values appear in the depths {0, 1, 1}, in this order.
Thus, the correct checksum to return is (0 * 10^0 + 1 * 10^5 + 1 * 10^10) modulo 1,000,000,007.
</p>

</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>9</pre></td></tr><tr><td><pre>{40, 20, 60, 70, 80, 30, 10, 30, 90}</pre></td></tr><tr><td><pre>0</pre></td></tr><tr><td><pre>100</pre></td></tr></table></td></tr><tr><td><pre>Returns: 461469106</pre></td></tr><tr><td><table><tr><td colspan="2">The example shown in the ASCII art drawing in the problem statement.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>15</pre></td></tr><tr><td><pre>{10, 20, 30}</pre></td></tr><tr><td><pre>100</pre></td></tr><tr><td><pre>1000000007</pre></td></tr></table></td></tr><tr><td><pre>Returns: 149719615</pre></td></tr><tr><td><table><tr><td colspan="2">The inserted values, in order:
10 20 30 1003 2004 3005 100306 200407 300508 10030609 20040710 30050811 3060905 4070997 5081091.</td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
