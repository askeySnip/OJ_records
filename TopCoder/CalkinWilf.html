<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
The Calkin-Wilf tree is a rooted tree that contains each positive rational number exactly once.
The definition of the tree is really simple: 
</p>
<ul>
<li>The root of the tree contains the value 1/1.</li>
<li>Each node in the tree has one left child and one right child.</li>
<li>If a node contains the fraction a/b, its left child contains the fraction a/(a+b) and its right child contains the fraction (a+b)/b.</li>
</ul>
<p>
Here is an ASCII art drawing of the first few levels of the tree:
</p>
<pre>
                ____________1/1____________
               /                           \
        ____1/2____                     ____2/1____
       /           \                   /           \
    1/3             3/2             2/3             3/1
   /   \           /   \           /   \           /   \
1/4     4/3     3/5     5/2     2/5     5/3     3/4     4/1
</pre>
<p>
You are given the string <b>path</b> that describes a path down the tree.
We start in the root and we read the characters of <b>path</b> one at a time.
Here, 'L' means "go to the left child" and 'R' means "go to the right child".
</p>
<p>
Find the fraction a/b that will be written in the last node we visit.
Return the vector &lt;int&gt; {a, b}.
</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>CalkinWilf</td></tr><tr><td>Method:</td><td>findRational</td></tr><tr><td>Parameters:</td><td>string</td></tr><tr><td>Returns:</td><td>vector &lt;int&gt;</td></tr><tr><td>Method signature:</td><td>vector &lt;int&gt; findRational(string path)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>The return value should be a vector &lt;int&gt; with two elements. Element 0 should be the numerator and element 1 should be the denominator of the fraction.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>path</b> will contain between 0 and 30 characters, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each character in <b>path</b> will be either 'L' or 'R'.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {1, 1 }</pre></td></tr><tr><td><table><tr><td colspan="2">If the path is empty, we end where we started: in the root.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;R&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {2, 1 }</pre></td></tr><tr><td><table><tr><td colspan="2">Taking a single step right takes us to the node with the value 2/1.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;LRR&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {5, 2 }</pre></td></tr><tr><td><table><tr><td colspan="2">This time we go 1/1 -> left to 1/2 -> right to 3/2 -> right to 5/2.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;LRLRLRLRLRLRLRLRLRLRLRLRLRLRLR&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {2178309, 1346269 }</pre></td></tr><tr><td><table><tr><td colspan="2">This is one possible longest valid input.</td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
